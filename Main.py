import public_class.Encrypt as Encrypt

import sys
import os
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from public_class import SQL_method

class Main:
    _instance = None

    # bindAccount_queue stores temporary binding information during the account binding process.
    # Each dictionary contains:
    # {
    #     "user_id": int,             # ID of the user
    #     "secret_key": str,          # User's unique secret key for OTP generation
    #     "counter": int,             # HOTP counter value
    #     "code": int                 # Random code for identifying or verifying the binding
    # }
    bindAccount_queue = [  {}]

    # queue_OTP stores recent OTPs for each user to verify incoming OTPs from devices.
    # Each dictionary contains:
    # {
    #     "user_id": int,             # ID of the user
    #     "OTPs": list[str]           # List of 5 OTPs (2 before, current counter, and 2 after current counter)
    # }
    queue_OTP = []


    # for register event.
    # when the user registers an account, conveniently bind the user's mobile phone.
    # if the code entered by the user matches the one-time code generated by the mobile phone, then the binding is successful.
    def isCodeInBindAccountQueue(cls, bind_code):
        for entry in cls.bindAccount_queue:
            if entry["code"] == int(bind_code):
                print("code =",bind_code)

                return entry["user_id"], entry["secret_key"]  
        return None, None 



    # server generate OTP by counter, then save into bindAccount_queue to wait for verity.
    # due to each client and server having its own counter, to improve fault tolerance, calculate the counters from the 2 before, current counter and after 2 counter.
    def generateHOTP(cls,user_id):
        newTuple = SQL_method.get_user_and_increaseOTPCounter(user_id)
        secret_key = newTuple[5]
        counter = newTuple[6]


        OTPs = [
            Encrypt.hotp(secret_key, counter - 2),
            Encrypt.hotp(secret_key, counter - 1),
            Encrypt.hotp(secret_key, counter),
            Encrypt.hotp(secret_key, counter + 1),
            Encrypt.hotp(secret_key, counter + 2)
        ]
        otp_entry = {
            "user_id": user_id,
            "OTPs": OTPs
        }

        cls.queue_OTP.append(otp_entry)

    def bindDeviceID(cls,user_id,deviceID):
         SQL_method.bindDeviceByUserID(deviceID,user_id)


    # check if OTP_fromMobile is in the queue_OTP queue.
    # if yes, return true(user login success). otherwise byebye.
    def verity_user_OTP(cls, OTP_fromMobile, user_id):

        for entry in cls.queue_OTP:
            if entry["user_id"] == user_id:
                if OTP_fromMobile in entry["OTPs"]:
                    print("OTP verified for user:", user_id)
                    return True
                else:
                    print("OTP mismatch for user:", user_id)
                    return False


        print("No OTP entry found for user:", user_id)
        return False








    # for Singleton pattern.
    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super(Main, cls).__new__(cls)
        return cls._instance